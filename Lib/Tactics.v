Require Import Coq.Bool.Bool.

Require Export Category.Lib.Setoid.

Generalizable All Variables.
Set Primitive Projections.
Set Universe Polymorphism.
Unset Transparent Obligations.

Open Scope lazy_bool_scope.

(** Basic tactics for category theory proofs *)
Ltac simplify :=
  repeat
    (match goal with
     | [ H : () |- _ ] => destruct H
     | [ |- () ] => exact tt

     | [ H : (_ &&& _) = true |- _ ] => rewrite <- andb_lazy_alt in H
     | [ |- (_ &&& _) = true ]       => rewrite <- andb_lazy_alt
     | [ H : (_ && _) = true |- _ ]  => apply andb_true_iff in H
     | [ |- (_ && _) = true ]        => apply andb_true_iff; split

     | [ H : _ ∧ _ |- _ ] =>
       let H' := fresh "H" in destruct H as [H H']
     | [ |- _ ∧ _ ] => split

     | [ H : _ /\ _ |- _ ] =>
       let H' := fresh "H" in destruct H as [H H']
     | [ |- _ /\ _ ] => split

     | [ H : _ ↔ _ |- _ ] =>
       let H' := fresh "H" in destruct H as [H H']
     | [ |- _ ↔ _ ] => split

     | [ H : (_, _) = (_, _) |- _ ] => inversion_clear H

     | [ H : _ * _ |- _ ] =>
       let x := fresh "x" in
       let y := fresh "y" in
       destruct H as [x y]
     | [ |- _ * _ ] => split

     | [ H : { _ : _ & _ } |- _ ] =>
       let x := fresh "x" in
       let e := fresh "e" in
       destruct H as [x e]
     | [ |- { _ : _ & _ } ] =>
       unshelve (refine (existT _ _ _))
     end; intros).

(** [cat] tactic is like [set_solver] in stdpp. But much weaker and faster. *)
Ltac cat :=
  simplify;
  autorewrite with categories;
  auto with category_laws;
  try reflexivity.

(** Hints for dealing with equivalences *)
#[export] Hint Constructors Equivalence : core.

#[export] Hint Unfold Reflexive : core.
#[export] Hint Unfold Symmetric : core.
#[export] Hint Unfold Transitive : core.

#[export] Hint Extern 1 (Reflexive ?X) =>
  unfold Reflexive : core.
#[export] Hint Extern 1 (Symmetric ?X) =>
  unfold Symmetric : core.
#[export] Hint Extern 1 (Transitive ?X) =>
  unfold Transitive : core.
#[export] Hint Extern 1 (Equivalence ?X) =>
  apply Build_Equivalence : core.
#[export] Hint Extern 1 (Proper _ _) => unfold Proper : core.
#[export] Hint Extern 8 (respectful _ _ _ _) =>
  unfold respectful : core.

#[export] Hint Extern 4 (equiv ?A ?A) => reflexivity : category_laws.
#[export] Hint Extern 6 (equiv ?X ?Y) =>
  apply Equivalence_Symmetric : category_laws.
#[export] Hint Extern 7 (equiv ?X ?Z) =>
  match goal with
    [H : equiv ?X ?Y, H' : equiv ?Y ?Z |- equiv ?X ?Z] => transitivity Y
  end : category_laws.

(** Useful when dealing with [Equivalence] instances. *)
Ltac equivalence :=
  constructor; repeat intro; simpl; try cat; intuition; auto with *.

(** Useful when dealing with [Proper] instances. *)
Ltac proper := repeat intro; simpl; try cat; intuition.

(** Rewrite using a term, simplifying it first. *)
Tactic Notation "srewrite" uconstr(F) :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite H; clear H.
Tactic Notation "srewrite" "->" uconstr(F) :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite -> H; clear H.
Tactic Notation "srewrite" "<-" uconstr(F) :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite <- H; clear H.

Tactic Notation "srewrite" uconstr(F) "in" hyp(H) :=
  let H' := fresh "H" in pose proof F as H'; cbn in H'; rewrite H' in H; clear H'.
Tactic Notation "srewrite" "->" uconstr(F) "in" hyp(H) :=
  let H' := fresh "H" in pose proof F as H'; cbn in H'; rewrite -> H' in H; clear H'.
Tactic Notation "srewrite" "<-" uconstr(F) "in" hyp(H) :=
  let H' := fresh "H" in pose proof F as H'; cbn in H'; rewrite <- H' in H; clear H'.

Tactic Notation "srewrite" uconstr(F) "in" "*" :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite H in *; clear H.
Tactic Notation "srewrite" "->" uconstr(F) "in" "*" :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite -> H in *; clear H.
Tactic Notation "srewrite" "<-" uconstr(F) "in" "*" :=
  let H := fresh "H" in pose proof F as H; cbn in H; rewrite <- H in *; clear H.

(** Apply a term, simplifying it first. *)
Tactic Notation "sapply" uconstr(F) :=
  let H := fresh "H" in pose proof F as H; cbn in H; apply H; clear H.
Tactic Notation "sapply" uconstr(F) "in" hyp(H) :=
  let H' := fresh "H" in pose proof F as H'; cbn in H'; apply H' in H; clear H'.

(** Simplify obligations generated by Program mode in category theory proofs *)
Ltac cat_simpl :=
  program_simpl; autounfold;
  try solve [
    repeat match goal with
    | [ |- Equivalence _ ] => equivalence
    | [ |- Proper _ _ ] => proper
    | [ |- respectful _ _ _ _ ] => proper
    end;
    program_simpl; autounfold in *;
    simpl in *; intros; simplify;
    simpl in *; cat];
  simpl in *.
#[global] Obligation Tactic := cat_simpl.

(** General form of [equivalence] or of [proper]. *)
Ltac construct := unshelve econstructor; simpl; intros.

(** Inversion with [subst] and [clear]. *)
Ltac inv H := inversion H; subst; try clear H.

(** Pose proof and simplify it. *)
Tactic Notation "spose" uconstr(H) "as" ident(X) :=
  pose proof H as X; simpl in X.

(** Clear a hypothesis and also its dependencies. Taken from Coq stdlib, with the
  * performance-enhancing change to [lazymatch] suggested at
  * [https://github.com/coq/coq/issues/11689].
  *)
Tactic Notation "clear" "dependent" hyp(h) :=
  let rec depclear h :=
  clear h ||
  lazymatch goal with
   | H : context [ h ] |- _ => depclear H; depclear h
  end ||
  fail "hypothesis to clear is used in the conclusion (maybe indirectly)"
 in depclear h.

(** A version of [generalize dependent] that applies only to a hypothesis.
  * Taken from Coq stdlib.
  *)
Tactic Notation "revert" "dependent" hyp(h) :=
  generalize dependent h.

(** Applying a tactic to a term with increasingly many arguments *)
Tactic Notation "do_with_holes" tactic3(x) uconstr(p) :=
  x uconstr:(p) ||
  x uconstr:(p _) ||
  x uconstr:(p _ _) ||
  x uconstr:(p _ _ _) ||
  x uconstr:(p _ _ _ _) ||
  x uconstr:(p _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

(** Same thing but starting with many holes first *)
Tactic Notation "do_with_holes'" tactic3(x) uconstr(p) :=
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _ _) ||
  x uconstr:(p _ _ _ _ _) ||
  x uconstr:(p _ _ _ _) ||
  x uconstr:(p _ _ _) ||
  x uconstr:(p _ _) ||
  x uconstr:(p _) ||
  x uconstr:(p).

(** A shorter name for [simple refine]. *)
Tactic Notation "srefine" uconstr(term) := simple refine term.
(** A shorter name for [notypeclasses refine];. *)
Tactic Notation "nrefine" uconstr(term) := notypeclasses refine term.
(** A shorter name for [simple notypeclasses refine]. *)
Tactic Notation "snrefine" uconstr(term) := simple notypeclasses refine term.

(** Note that the Coq standard library has a [rapply], but it is like our [rapply']
  * with many-holes first. We prefer fewer-holes first, for instance so that a
  * theorem producing an equivalence will by preference be used to produce an
  * equivalence rather than to apply the coercion of that equivalence to a function.
  *)
Tactic Notation "rapply" uconstr(term)
  := do_with_holes ltac:(fun x => refine x) term.
Tactic Notation "rapply'" uconstr(term)
  := do_with_holes' ltac:(fun x => refine x) term.

Tactic Notation "srapply" uconstr(term)
  := do_with_holes ltac:(fun x => srefine x) term.
Tactic Notation "srapply'" uconstr(term)
  := do_with_holes' ltac:(fun x => srefine x) term.

Tactic Notation "nrapply" uconstr(term)
  := do_with_holes ltac:(fun x => nrefine x) term.
Tactic Notation "nrapply'" uconstr(term)
  := do_with_holes' ltac:(fun x => nrefine x) term.

Tactic Notation "snrapply" uconstr(term)
  := do_with_holes ltac:(fun x => snrefine x) term.
Tactic Notation "snrapply'" uconstr(term)
  := do_with_holes' ltac:(fun x => snrefine x) term.

(** Multi-term versions of [rapply], [srapply], [nrapply], [snrapply] *)
#[export] Module RApplyExtensions.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) := rapply P1; rapply P2.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) := rapply P1 P2; rapply P3.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) := rapply P1 P2 P3; rapply P4.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) := rapply P1 P2 P3 P4; rapply P5.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) := rapply P1 P2 P3 P4 P5; rapply P6.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) := rapply P1 P2 P3 P4 P5 P6; rapply P7.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) := rapply P1 P2 P3 P4 P5 P6 P7; rapply P8.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) := rapply P1 P2 P3 P4 P5 P6 P7 P8; rapply P9.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9; rapply P10.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10; rapply P11.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11; rapply P12.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12; rapply P13.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13; rapply P14.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14; rapply P15.
  Tactic Notation "rapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) uconstr(P16) := rapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15; rapply P16.

  Tactic Notation "srapply" uconstr(P1) uconstr(P2) := srapply P1; srapply P2.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) := srapply P1 P2; srapply P3.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) := srapply P1 P2 P3; srapply P4.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) := srapply P1 P2 P3 P4; srapply P5.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) := srapply P1 P2 P3 P4 P5; srapply P6.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) := srapply P1 P2 P3 P4 P5 P6; srapply P7.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) := srapply P1 P2 P3 P4 P5 P6 P7; srapply P8.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) := srapply P1 P2 P3 P4 P5 P6 P7 P8; srapply P9.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9; srapply P10.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10; srapply P11.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11; srapply P12.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12; srapply P13.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13; srapply P14.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14; srapply P15.
  Tactic Notation "srapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) uconstr(P16) := srapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15; srapply P16.

  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) := nrapply P1; nrapply P2.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) := nrapply P1 P2; nrapply P3.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) := nrapply P1 P2 P3; nrapply P4.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) := nrapply P1 P2 P3 P4; nrapply P5.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) := nrapply P1 P2 P3 P4 P5; nrapply P6.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) := nrapply P1 P2 P3 P4 P5 P6; nrapply P7.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) := nrapply P1 P2 P3 P4 P5 P6 P7; nrapply P8.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) := nrapply P1 P2 P3 P4 P5 P6 P7 P8; nrapply P9.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9; nrapply P10.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10; nrapply P11.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11; nrapply P12.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12; nrapply P13.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13; nrapply P14.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14; nrapply P15.
  Tactic Notation "nrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) uconstr(P16) := nrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15; nrapply P16.

  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) := snrapply P1; snrapply P2.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) := snrapply P1 P2; snrapply P3.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) := snrapply P1 P2 P3; snrapply P4.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) := snrapply P1 P2 P3 P4; snrapply P5.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) := snrapply P1 P2 P3 P4 P5; snrapply P6.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) := snrapply P1 P2 P3 P4 P5 P6; snrapply P7.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) := snrapply P1 P2 P3 P4 P5 P6 P7; snrapply P8.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) := snrapply P1 P2 P3 P4 P5 P6 P7 P8; snrapply P9.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9; snrapply P10.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10; snrapply P11.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11; snrapply P12.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12; snrapply P13.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13; snrapply P14.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14; snrapply P15.
  Tactic Notation "snrapply" uconstr(P1) uconstr(P2) uconstr(P3) uconstr(P4) uconstr(P5) uconstr(P6) uconstr(P7) uconstr(P8) uconstr(P9) uconstr(P10) uconstr(P11) uconstr(P12) uconstr(P13) uconstr(P14) uconstr(P15) uconstr(P16) := snrapply P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15; snrapply P16.
End RApplyExtensions.